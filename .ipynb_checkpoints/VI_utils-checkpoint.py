{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os, sys, glob\n",
    "import numpy as np\n",
    "\n",
    "from astropy.io import fits\n",
    "from astropy.table import Table, join, vstack\n",
    "from astropy.io import fits\n",
    "\n",
    "import pandas as pd\n",
    "import fnmatch\n",
    "\n",
    "import desispec.io\n",
    "\n",
    "import matplotlib.pyplot as plt \n",
    "\n",
    "\n",
    "def read_individual_VI(VI_dir):\n",
    "    \n",
    "    #we will read all the *.csv files in the VI_dir. Change as needed.\n",
    "\n",
    "    print('Reading all individual VI files in '+VI_dir)\n",
    "    \n",
    "    all_files = os.listdir(VI_dir)\n",
    "    vi_files=[]\n",
    "\n",
    "    pattern = \"desi*.csv\"\n",
    "    for entry in all_files:\n",
    "        if fnmatch.fnmatch(entry, pattern):\n",
    "            vi_files.append(entry)\n",
    "\n",
    "    vi = pd.read_csv(VI_dir + vi_files[0], delimiter = \" , \", engine='python')\n",
    "\n",
    "    for i in range(1,len(vi_files)):\n",
    "        print(vi_files[i])\n",
    "        vi2 = pd.read_csv(VI_dir + vi_files[i], delimiter = \" , \", engine='python')\n",
    "        vi = vi.append(vi2, ignore_index=True)\n",
    "    \n",
    "    return vi\n",
    "\n",
    "def find_conflicts(vi_gp):\n",
    "    vi_conflict = vi_gp.filter(lambda x: ( ( (x['VI class'].max()-x['VI class'].min()) >= 2) \n",
    "                       | ( (x['best redshift'].max() - x['best redshift'].min()) / (1+x['best redshift'].min()) > 0.0033 ) \n",
    "                       | (not all(i == x['best spectype'].iloc[0] for i in x['best spectype'])) )\n",
    "                       & (x['VI class'].max() > 2)\n",
    "                       & (len(x) >= 2)) #x is a group by TargetID)\n",
    "    return vi_conflict\n",
    "\n",
    "\n",
    "def prep_new_columns(vi):\n",
    "    #make new column with best redshift estimate for each VI - take VI redshift if available, else take Redrock redshift. \n",
    "    #I am always assuming that the VI redshift, if provided, trumps over the Redrock redshift. \n",
    "    vi['best redshift'] = vi['VI z']\n",
    "    vi.loc[vi['best redshift']=='--', 'best redshift'] = vi.loc[vi['best redshift']=='--', 'Redrock z']\n",
    "    vi.loc[vi['best redshift']=='Target ', 'best redshift'] = 0 #catch someone who wrote in VI z field\n",
    "    vi['best redshift'] = vi['best redshift'].astype(float)\n",
    "    \n",
    "    #make new column with best spectype estimate for each VI - take VI spectype if available, else take Redrock spectype \n",
    "    #I am always assuming that the VI redshift, if provided, trumps over the Redrock redshift. \n",
    "    vi['best spectype'] = vi['VI spectype']\n",
    "    vi.loc[vi['best spectype']=='--', 'best spectype'] = vi.loc[vi['best spectype']=='--', 'Redrock spectype']\n",
    "    \n",
    "    #add new columns, holding the mean of the flags and the maximum difference in flag classification\n",
    "    vi['vi_combined_flag'] = vi.groupby('TargetID')['VI class'].transform('mean')\n",
    "    vi['vi_diff'] = vi.groupby('TargetID')['VI class'].transform(lambda x: ( x.max()-x.min()) )\n",
    "    \n",
    "    #add new column, difference in 'best redshift'\n",
    "    vi['dz'] = vi.groupby('TargetID')['best redshift'].transform(lambda x: ( (x.max() - x.min()) / (1+x.min()) ))\n",
    "    #add new column with the mean of best redshift if they're within 0.0033*(1+z)\n",
    "    vi.loc[vi.dz < 0.0033, 'vi_combined_z'] = vi.loc[vi.dz < 0.0033].groupby('TargetID')['best redshift'].transform('mean')\n",
    "    #keep as redrock z is difference is greater. These will be manually resolved if at least one of the inspectors flags a z as flag >2\n",
    "    vi.loc[vi.dz >= 0.0033, 'vi_combined_z'] = vi.loc[vi.dz >= 0.0033, 'Redrock z']\n",
    "    \n",
    "    #add new column, with all comments concatenated\n",
    "    #this protects agains None in 'VI comment' field\n",
    "    bad_str = [s is None for s in vi['VI comment']]\n",
    "    vi.loc[bad_str,'VI comment']='--'\n",
    "    vi['all VI comments'] = vi.groupby('TargetID')['VI comment'].transform(lambda x: '|'.join(x))\n",
    "    \n",
    "    #add new column, with the number of VI inspections for each object\n",
    "    vi['N_VI'] = vi.groupby('TargetID')['TargetID'].transform('count')\n",
    "    \n",
    "    #add new column to hold comments from merger if needed\n",
    "    vi['merger comment'] = 'none'\n",
    "    \n",
    "    return vi"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "DESI 19.2",
   "language": "python",
   "name": "desi-19.2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
